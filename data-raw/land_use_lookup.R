## code to prepare `land_use_lookup` dataset
## template generated by running `usethis::use_data_raw('land_use_lookup')`

## dependencies: `pdftools`, `RSQLite`, `DBI`, `dplyr`, `usethis` packages and two input files (see below)
## inputs: change the pdf_path and swat_path to the correct paths on your local machine!
## output: in your package data directory: /data/land_use_lookup.rda


## constants

# PDF of open access paper at https://doi.org/10.5194/hess-22-2527-2018
pdf_path = 'D:/rswat.uyr/data-raw/refs/hess-22-2527-2018.pdf'

# SQLite database from SWAT+ Installation or https://bitbucket.org/swatplus/swatplus.editor/downloads/
swat_path = 'C:/SWAT/SWATPlus/Databases/swatplus_datasets.sqlite'


## helpers

# Copy the table on the 18th page of the PDF at `pdf_path`
parse_pdf = function(pdf_path) {

  # users might be able to adapt this code to another table in the literature...
  pdf_txt = strsplit(pdftools::pdf_text(pdf_path)[[18]], '\n')[[1]]

  # ... but this regex for spacing patterns would likely need to be tweaked...
  tidy_txt = pdf_txt[grepl('^\\s+[0-9]+\\s+', pdf_txt)] |> trimws() |> strsplit('[\\s]{2,}', perl=TRUE)

  # ... same for the column names
  lu_table = do.call(rbind, tidy_txt) |> as.data.frame() |> setNames(c('id', 'desc', 'name', 'desc2'))
  lu_table[['id']] = as.integer(lu_table[['id']])
  lu_table[['name']] = tolower(lu_table[['name']])
  return(lu_table)
}

# Return a lookup tibble of SWAT codes matched to NLCD IDs
nlcd_codes = function(lu_table, swat_path) {

  # required columns in lu_table: 'id' (NLCD code), 'name' (in SWAT), 'desc' (description)
  # swat_path should point to the SWAT+ database file "swatplus_datasets.sqlite"
  swat_con = DBI::dbConnect(RSQLite::SQLite(), swat_path)

  # copy two land use parameter tables from QSWAT database
  urban_urb = DBI::dbReadTable(swat_con, 'urban_urb')
  plants_plt = DBI::dbReadTable(swat_con, 'plants_plt')
  DBI::dbDisconnect(swat_con)

  # combine into a single table
  landuse_swat = rbind(urban_urb[c('name', 'description')],
                       plants_plt[c('name', 'description')])

  # map NLCD id codes in lu_table to SWAT codes
  idx_nlcd = landuse_swat[['name']] |> match(lu_table[['name']])
  landuse_swat[['id']] = lu_table[['id']][idx_nlcd]

  # add descriptions (for human consumption, SWAT+ ignores them)
  landuse_swat[['description']] = landuse_swat[['description']] |>
    paste('>>>', lu_table[['desc']][idx_nlcd])

  # return in a fixed order
  landuse_swat = landuse_swat |> dplyr::arrange(id) |> dplyr::select(c('id', 'name', 'description'))
  return( landuse_swat )
}


## run

# call both functions to make the land use lookup table
land_use_lookup = pdf_path |> parse_pdf() |> nlcd_codes(swat_path)

# hard coded values to assign unmatched entries
land_use_lookup = land_use_lookup |> rbind( do.call(rbind, list(
  
  # reference: Arnold et al, 2010 tech report
  # at https://www.nrcs.usda.gov/sites/default/files/2023-04/ceap-crop-2010-HUMUS-SWAT-NWQM-DB.pdf
  data.frame(id=c(11, 12), name='watr', description='water >>> Open Water'),
  data.frame(id=31, name='barn', description='sparsely_vegetated >>> Barren'),
  data.frame(id=c(52, 72), name='rnge', description='range_grasses >>> Grassland/herbaceous'),
  data.frame(id=c(73, 74), name='tubg', description='bare_ground_tundra >>> Mosses/Lichens'),
  data.frame(id=c(91, 93), name='wetf', description='forested_wetland >>> Forested Wetland'),
  data.frame(id=c(94, 96, 97), name='wetl', description='nonforest_wetland >>> Non-forest Wetland')
  
)))

# omit NA rows then sort
land_use_lookup = land_use_lookup[!is.na(land_use_lookup[['id']]), ]
land_use_lookup = land_use_lookup[order(land_use_lookup[['id']]), ]
row.names(land_use_lookup) = NULL

# save as package data
usethis::use_data(land_use_lookup, overwrite=TRUE)
