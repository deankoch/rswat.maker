#' Find the appropriate UTM zone for a geometry 
#' 
#' This prints the UTM zone that covers the supplied point
#' and returns the corresponding EPSG code 
#'
#' @param x any object understood by `sf::st_geometry`
#'
#' @return integer EPSG code
#' @export
#'
#' @examples
#' c(-110, 45) |> sf::st_point() |> to_utm()
to_utm = function(x) {
  
  # longitude and latitude from first element in the geometry collection
  xy = x |> sf::st_geometry() |> sf::st_transform(4326) |> head(1) |> sf::st_coordinates()
  lon = xy[1]
  lat = xy[2]
  
  # UTM zone number from longitude
  utm_num = floor((lon + 180) / 6) + 1
  message(paste('UTM zone:', utm_num))

  # EPSG code from zone and signe of latitude (N/S)
  32700 + utm_num - 100*( sign(lat) + 1 )/2 
}

#' EPSG codes for some common geographical coordinate systems 
#'
#' These are some of the datum names I have encountered in NWIS. If `code`
#' is not 'NAD27' or 'NAD83', the function assumes the WGS84 datum.
#'
#' @param code character, the datum name
#'
#' @return integer, the EPSG code
#' @export
#'
#' @examples
#' datum_to_epsg('WGS84')
#' datum_to_epsg('NAD27')
#' datum_to_epsg('some_unknown_datum')
datum_to_epsg = \(code) {
  
  code |> switch('NAD27' = 4267,
                 'NAD83' = 4269,
                 'WGS84' = 4326, 4326)
}


#' Return a vector of all downstream COMID values
#'
#' This uses the 'FROMCOMID' and 'TOCOMID' fields in the `edge` table to follow
#' the directed graph of flow lines downstream from the polygon represented by
#' the input(s) `comid`, all the way to the eventual outlet(s). The function returns
#' all COMIDs on the path(s) in a vector.
#' 
#' `comid` should be listed in `edge[['FROMCOMID']]`, otherwise the function
#' simply returns its first argument. `edge` is normally generated by `get_catch`
#' (which calls `get_upstream` to fetch it via `nhdR`) but it can be any data
#' frame with the same type of graph structure in the fields 'FROMCOMID' and
#' 'TOCOMID' (see examples).
#'
#' @param comid character vector, the COMID(s) uniquely identifying the catchment(s) of interest
#' @param edge data frame, the NHD "PlusFlow" table (see `?get_upstream`) 
#'
#' @return character vector, the COMID values encountered on the way to the outlet (in order)
#' @export
#'
#' @examples
#' # dummy table - these are not real COMIDs!
#' edge_eg = data.frame(
#'  FROMCOMID=c('00', '00', '10', '11', '20'),
#'  TOCOMID=c('10', '11', '20', '20', '30'))
#' 
#' # follow from upstream of fork
#' comid_down('00', edge_eg)
#' 
#' # follow from one side of fork then the other
#' comid_down('10', edge_eg)
#' comid_down('11', edge_eg)
#' 
comid_down = function(comid, edge, first_only=FALSE) { 
  
  # returns immediate downstream COMID(s) or empty character (if none)
  if(first_only) return( edge[['TOCOMID']][ edge[['FROMCOMID']] %in% comid ] )
  
  # if no downstream links return current node(s) only
  comid_found = comid_down(comid, edge, first_only=TRUE)
  if( length(comid_found) == 0 ) return(comid)
  
  # else call the function recursively on downstream node(s)
  return( unique( c(comid, comid_down(comid_found, edge)) ) )
}

#' Return a vector of all upstream COMID values
#'
#' This uses the 'FROMCOMID' and 'TOCOMID' fields in the `edge` table to follow
#' the directed graph of flow lines upstream from the polygon(s) represented by
#' the input `comid`. The function exhaustively checks all relevant branches in
#' a loop, returning all upstream COMID values in a vector
#' 
#' All entries of `comid` should be listed in `edge[['FROMCOMID']]`. Normal usage
#' is to pass a single value to `comid` identifying your outlet of interest. The
#' function uses vectorized calls internally.
#' 
#' `edge` is normally generated by `get_catch` (which calls `get_upstream` to fetch
#' it via `nhdR`) but it can be any data frame with the same type of graph structure
#' in the fields 'FROMCOMID' and 'TOCOMID' (see examples).
#'
#' @param comid character vector, the COMID values to start from
#' @param edge data frame, the NHD "PlusFlow" table (see `?get_upstream`) 
#'
#' @return character vector, the COMID values for polygons draining into the outlet
#' @export
#'
#' @examples
#' # dummy table - these are not real COMIDs!
#' edge_eg = data.frame(
#'  FROMCOMID=c('00', '00', '10', '11', '20'),
#'  TOCOMID=c('10', '11', '20', '20', '30'))
#' 
#' # follow from downstream of fork to get all nodes
#' comid_up('30', edge_eg)
#' 
#' # follow from one side of fork then the other
#' comid_up('10', edge_eg)
#' comid_up('11', edge_eg)
comid_up = function(comid, edge, first_only=FALSE) { 
  
  # returns immediate upstream COMID(s) or empty character (if none)
  if(first_only) {
    
    comid_found = edge[['FROMCOMID']][ edge[['TOCOMID']] %in% comid ]
    
    # code '0' represents headwaters polygon (ie a dead end)
    comid_found = comid_found[ comid_found != '0' ]
    return(comid_found) 
  }
  
  # if no upstream links return current node(s) only
  comid_found = comid_up(comid, edge, first_only=TRUE)
  if( length(comid_found) == 0 ) return(comid)
  
  # else call the function on upstream nodes
  return( c(comid, comid_up(comid_found, edge)) )
}


#' Omit all but the largest in a set of polygons
#' 
#' This selects the largest polygon from a set, transforms to WGS84 coordinates,
#' runs `sf::st_make_valid()`, then removes holes from the result.
#' 
#' This is useful for tidying up the result of set operations (like differencing)
#' when the expected result is a single connected polygon.
#'
#' @param poly_list any object for which `sf::st_geometry() |> sf::st_area()` is valid
#'
#' @return an sfc_polygon object
#' @export
biggest_poly = function(poly_list) {
  
  poly_list = poly_list |> sf::st_geometry() |> sf::st_make_valid()
  do.call(c, lapply(seq_along(poly_list), \(i) {

    # selects max area polygon from the set than transforms back to WGS84
    p = poly_list[i] |> sf::st_cast('POLYGON') |> sf::st_make_valid()
    p = p[ which.max( sf::st_area(p) ) ] |> sf::st_transform(4326) |> sf::st_make_valid() 
    
    # remove holes from result (using the trick in `mapsf::mf_scale`)
    p = sf::st_multipolygon(lapply(p, function(x) x[1])) |> sf::st_geometry()
    sf::st_crs(p) = 4326
    return(p)
    
  }))
}


