#' Return a point given a place-name query using Nominatim API for OpenStreetMaps (OSM)
#' 
#' This submits a single query to OSM and returns either a single result, the
#' WGS84 coordinates for the point that (most closely) matches the query, or else
#'`NULL` to indicate no results.
#' 
#' The function also prints the "display_name" field returned by OSM
#' 
#' Loosely based on code by D. Kisler at https://tinyurl.com/2xxcthp5 
#' See also the Nominatim API documentation at
#' https://nominatim.org/release-docs/latest/api
#'
#' @param query character, query to submit to Nominatim API
#'
#' @return sfc_POINT object or NULL for no results 
#' @export
#'
#' @examples
#' nominatim_point('nonexistent placename')
#' nominatim_point('Old Faithful')
nominatim_point = function(query, quiet=FALSE) {
  
  base_url = 'https://nominatim.openstreetmap.org'
  query_extra = '&limit=1&format=json'
  query_norm = gsub('\\s+', '\\%20', query[[1]])
  
  # urls for query and checking server status
  query_url = base_url |> file.path(paste0('search?q=', query_norm, query_extra))
  status_url = base_url |> file.path('status.php?format=json')
  
  # status check
  if( !is.character(query) ) {
    
    status_result = status_url |> jsonlite::fromJSON()
    message('server status: ', status_result[['message']])
    return(invisible())
  }
  
  # search
  query_result = tryCatch({
    
    # send the query and open result as JSON
    nominatim_result = query_url |> jsonlite::fromJSON()
    
    # print the first result name and return coordinates as sfc object
    if( is.null(nominatim_result[['display_name']]) ) { NULL } else {
      
      if(!quiet) message('OSM name: ',  nominatim_result[['display_name']] )
      nominatim_result[c('lon', 'lat')] |> 
        unlist() |> 
        as.numeric() |> 
        sf::st_point() |> 
        sf::st_sfc(crs='EPSG:4326')
    }
    
  }, error = \(e) {
    
    message('error: ', as.character(e))
    NULL
  })
  
  # no results case returns NULL invisibly
  if( length(query_result) == 0 ) {
    
    if(!quiet) message('no results')
    return( invisible(query_result) )
  }
  
  return(query_result)
}


#' Find the appropriate UTM zone for a geometry 
#' 
#' This prints the UTM zone that covers the supplied point
#' and returns the corresponding EPSG code as integer
#'
#' @param x any object with CRS data understood by `sf::st_geometry`
#'
#' @return integer EPSG code
#' @export
#'
#' @examples
#' c(-110, 45) |> sf::st_point() |> get_utm()
get_utm = function(x, quiet=FALSE) {
  
  # longitude and latitude from first element in the geometry collection
  xy = x |> sf::st_geometry() |> sf::st_transform(4326) |> head(1) |> sf::st_coordinates()
  lon = xy[1]
  lat = xy[2]
  
  # UTM zone number from longitude
  utm_num = floor((lon + 180) / 6) + 1
  if(!quiet) message(paste('UTM zone:', utm_num))

  # EPSG code from zone and signe of latitude (N/S)
  32700 + utm_num - 100*( sign(lat) + 1 )/2 
}

#' EPSG codes for some common geographical coordinate systems 
#'
#' These are some of the datum names I have encountered in NWIS. If `code`
#' is not 'NAD27' or 'NAD83', the function assumes the WGS84 datum.
#'
#' @param code character, the datum name
#'
#' @return integer, the EPSG code
#' @export
#'
#' @examples
#' datum_to_epsg('WGS84')
#' datum_to_epsg('NAD27')
#' datum_to_epsg('some_unknown_datum')
datum_to_epsg = \(code) {
  
  code |> switch('NAD27' = 4267,
                 'NAD83' = 4269,
                 'WGS84' = 4326, 4326)
}


#' Return a vector of all downstream COMID values
#'
#' This uses the `from` and `to` fields in the `edge` table (by default 'FROMCOMID'
#' and 'TOCOMID') to traverse the directed graph of flow lines downstream from the 
#' input(s) `comid`, all the way to the eventual outlet(s). The function returns
#' all keys encountered along the way in a vector.
#' 
#' `comid` should be listed in `edge[['FROMCOMID']]`, otherwise the function
#' simply returns its first argument. `edge` is normally generated by `get_catch`
#' (which calls `get_upstream` to fetch it via `nhdR`) but it can be any data
#' frame with the same type of graph structure.
#'
#' @param comid character vector, the key(s) downstream of `comid`
#' @param edge data frame, the NHD "PlusFlow" table or similar (see `?get_upstream`) 
#' @param first_only logical, whether to return only the first level of downstream COMID(s)
#' @param from character field name, the origin key
#' @param to character field name, the destination key
#'
#' @return character vector, the key values encountered on the way to the outlet (in order)
#' @export
#'
#' @examples
#' # dummy table - these are not real COMIDs!
#' edge_eg = data.frame(
#'  FROMCOMID=c('00', '00', '10', '11', '20'),
#'  TOCOMID=c('10', '11', '20', '20', '30'))
#' 
#' # follow from upstream of fork
#' comid_down('00', edge_eg)
#' 
#' # follow from one side of fork then the other
#' comid_down('10', edge_eg)
#' comid_down('11', edge_eg)
#' 
comid_down = function(comid, edge, first_only=FALSE, from='FROMCOMID', to='TOCOMID') { 
  
  # returns immediate downstream COMID(s) or empty character (if none)
  if(first_only) return( edge[[to]][ edge[[from]] %in% comid ] )
  
  # if no downstream links return current node(s) only
  comid_found = comid_down(comid, edge, first_only=TRUE, from=from, to=to)
  if( length(comid_found) == 0 ) return(comid)
  
  # else call the function recursively on downstream node(s)
  return( unique( c(comid, comid_down(comid_found, edge, from=from, to=to)) ) )
}

#' Return a vector of all upstream COMID values
#'
#' By default this uses 'FROMCOMID' and 'TOCOMID' fields in the `edge` table to
#' follow the directed graph of flow lines upstream from key value `comid`. All flow
#' lines are assumed to terminate at `to=hw`, which for NHD data uses the
#' character key '0'.
#' 
#' This was originally written for COMID fields in NHD tables returned by `nhdR`, but
#' it should work with any similarly structured data frame. Set `from` and `to` to 
#' used to specify different columns to follow (eg DSLINK fields from TauDEM output
#' returned by QSWAT+), making sure that `hw` is set properly. Keys can be integer
#' or character.
#' 
#' If `first_only=TRUE` the function returns only the key(s) found immediately
#' upstream (if any). Otherwise the function exhaustively checks all relevant branches in
#' a loop, returning all unique upstream keys in a vector.
#' 
#' All entries of `comid` should be found in `edge[['from']]`. Normal usage
#' is to pass a single value to `comid` identifying your outlet of interest. However,
#' you can pass vectors to `comid` to get results for all of the inputs, concatenated
#' in a single vector with duplicates removed.
#'
#' @param comid character vector, the key value to start from
#' @param edge data frame, the NHD "PlusFlow" table (see `?get_upstream`) or similar 
#' @param first_only logical, whether to return only the first level of upstream COMID(s)
#' @param from character field name, the origin key
#' @param to character field name, the destination key
#' @param hw length-1 of class matching the `from` and `to` columns of `edge`, headwater code
#'
#' @return character vector, the COMID values for polygons draining to (one of) `comid`
#' @export
#'
#' @examples
#' # dummy table - these are not real COMIDs!
#' edge_eg = data.frame(
#'  FROMCOMID=c('00', '00', '10', '11', '20'),
#'  TOCOMID=c('10', '11', '20', '20', '30'))
#' 
#' # follow from downstream of fork to get all nodes
#' comid_up('30', edge_eg)
#' 
#' # follow from one side of fork then the other
#' comid_up('10', edge_eg)
#' comid_up('11', edge_eg)
comid_up = function(comid, edge, first_only=FALSE, from='FROMCOMID', to='TOCOMID', hw='0') { 
  
  # returns immediate upstream COMID(s) or empty character (if none)
  if(first_only) {
    
    comid_found = edge[[from]][ edge[[to]] %in% comid ]
    comid_found = comid_found[ comid_found != hw ]
    return(comid_found) 
  }
  
  # if no upstream links return current node(s) only
  comid_found = comid_up(comid, edge, first_only=TRUE, from=from, to=to, hw=hw)
  if( length(comid_found) == 0 ) return(comid)
  
  # else call the function on upstream nodes
  return( c(comid, comid_up(comid_found, edge, from=from, to=to, hw=hw)) )
}


#' Omit all but the largest in a set of polygons
#' 
#' This selects the largest polygon from a set, transforms to WGS84 coordinates,
#' runs `sf::st_make_valid()`, then removes holes from the result.
#' 
#' We use it in this package for tidying up the result of set operations like
#' differencing, where we are expecting a simple connected polygon but don't always
#' get one because of imprecise geometries.
#'
#' @param poly_list any object for which `sf::st_geometry() |> sf::st_area()` is valid
#'
#' @return an sfc_polygon object
#' @export
#'
#' @examples
#' # a state boundary formed from incomplete set of pieces
#' county = system.file('shape/nc.shp', package='sf') |> sf::st_read(quiet=TRUE) |> sf::st_geometry()
#' state = sf::st_geometry(county)[-27] |> sf::st_union()
#' 
#' # plot state and counties
#' # plot(state, border=NA, col='grey50')
#' # plot(county, add=TRUE, border='grey70')
#' 
#' # call the function - area isn't reduced much
#' state_simple = biggest_poly(state)
#' sf::st_area(state_simple)
#' sf::st_area(state)
#' 
#' # but disconnected coastal pieces and the interior hole are gone
#' # plot(state, border=NA, col='grey50')
#' # plot(county, add=TRUE, border='grey70')
#' # plot(state_simple, add=TRUE, lwd=2)
biggest_poly = function(poly_list) {
  
  poly_list = poly_list |> sf::st_geometry() |> sf::st_make_valid()
  do.call(c, lapply(seq_along(poly_list), \(i) {

    # selects max area polygon from the set than transforms back to WGS84
    p = poly_list[i] |> sf::st_cast('POLYGON') |> sf::st_make_valid()
    p = p[ which.max( sf::st_area(p) ) ] |> 
      sf::st_transform(4326) |> 
      sf::st_make_valid() |> 
      sf::st_cast('POLYGON')

    # remove holes from result (using the trick in `mapsf::mf_scale`)
    p = sf::st_multipolygon(lapply(p, function(x) x[1])) |> sf::st_geometry()
    sf::st_crs(p) = 4326
    return(p)
    
  }))
}


#' Crop and mask a raster to a (possibly padded) geometry
#' 
#' The function wraps the obvious `terra` and `sf` functions, handling projections, and
#' coercing to `SpatVector` via `sp` to avoid possible bugs.
#' 
#' This returns a copy the sub-grid of raster `r` covering geometry `b` (or optionally a
#' buffered version returned by `sf::st_buffer`), where all pixels lying outside the geometry
#' set to NA. If `p` is not `NULL`, the function deletes anything at that path, then writes
#' the raster to it with `terra::writeRaster` (creating directories as needed)
#' 
#' Set the padding distance in argument `buffer`, or 0 for no padding. This value is passed
#' directly to `sf::st_buffer` if it is finite, otherwise the function does no masking or
#' cropping and ignores `b`.
#'
#' @param r SpatRaster
#' @param b sf polygon geometry within extent of `r`
#' @param p character path to save as GeoTIFF
#' @param buffer numeric >= 0 (possibly with units), distance by which to expand the boundary of `b`
#'
#' @return SpatRaster
#' @export
#' 
#' @examples
#' dem = terra::rast(system.file('ex/elev.tif', package='terra'))
#' bbox = dem |> terra::ext() |> sf::st_bbox() |> sf::st_as_sfc()
#' sf::st_crs(bbox) = sf::st_crs(dem)
#' buffer = units::set_units(10, km)
#' b = sf::st_centroid(bbox) |> sf::st_buffer(buffer)
#' # dem |> terra::plot()
#' # plot(b, add=T)
#' 
#' # clipr result
#' r_result = dem |> clipr(b)
#' # r_result |> terra::plot()
#' # plot(b, add=T)
#' 
#' # same result using buffer argument
#' r_result2 = dem |> clipr(sf::st_centroid(bbox), buffer)
#' all.equal(r_result, r_result2)
#' 
clipr = function(r, b, buffer=0, p=NULL) {

  # infinite buffer means just return/write the raster unchanged
  if( !is.infinite(buffer) ) {
    
    # clean up input boundary
    b = b[!sf::st_is_empty(b)] |> sf::st_geometry()
    
    # add buffer on request
    if( as.numeric(buffer) > 0 ) {
      
      # transform to UTM for the calculation if needed
      crs_b = sf::st_crs(b)
      utm_b = get_utm(b) |> suppressMessages()
      if( sf::st_is_longlat(b) ) b = b |> sf::st_transform(utm_b)
      b = b |> sf::st_buffer(buffer) |> sf::st_transform(crs_b)
    }
    
    # SpatVector version of boundary for mask
    b_sv = b |> sf::st_transform(sf::st_crs(r)) |> as('Spatial') |> as('SpatVector')
    r = r |> terra::crop(b_sv) |> terra::mask(b_sv)
  }
 
  # write the file
  if( !is.null(p) ) {
    
    p_parent = dirname(p)
    if( !dir.exists(p_parent) ) dir.create(p_parent, recursive=TRUE)
    r |> terra::writeRaster(p)
  }
  
  return(r)
}


#' Return the most frequent string a column of a data frame
#'
#' The counts the appearances of unique strings in `x[[nm]]` and returns the
#' most frequent one. If there is a tie, the function returns the one appearing
#' first in the data frame. If there are no non-empty strings, the function
#' returns `alt`
#'
#' @param x data frame with character column at `nm`
#' @param nm character or integer identifying the column to check
#' @param alt character, returned when in place of `NA`
#'
#' @return character
#' @export
#' 
#' @examples
#' # two types of high-priority package, which is more frequent?  
#' df_nm = installed.packages(priority='high') |> as.data.frame()
#' df_nm[['Priority']] |> unique()
#' df_nm |> most_frequent('Priority')
#' 
#' # empty column or ties produce `alt`
#' df_nm |> most_frequent('MD5sum')
#' df_nm |> most_frequent('Package')
#' 
#' # index by column number
#' most_frequent(df_nm, which(nm_all=='Suggests') )
most_frequent = function(df_nm, nm=1, alt='unnamed') {
  
  char_options = df_nm[[nm]] |> table(useNA='no') |> sort()
  if( all( char_options == char_options[1] ) ) char_options = ''
  char_out = char_options |> tail(1) |> names()
  if( is.null(char_out) ) char_out = alt
  if( nchar(char_out) == 0 ) char_out = alt
  return(char_out)
}
