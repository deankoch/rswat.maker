#' Find the appropriate UTM zone for a geometry 
#' 
#' This prints the UTM zone that covers the supplied point
#' and returns the corresponding EPSG code 
#'
#' @param x any object understood by `sf::st_geometry`
#'
#' @return integer EPSG code
#' @export
#'
#' @examples
#' c(-110, 45) |> sf::st_point() |> to_utm()
to_utm = function(x) {
  
  # longitude and latitude
  xy = x |> sf::st_geometry() |> sf::st_transform(4326) |> sf::st_coordinates()
  lon = xy[1]
  lat = xy[2]
  
  # UTM zone number from longitude
  utm_num = floor((lon + 180) / 6) + 1
  message(paste('UTM zone:', utm_num))

  # EPSG code from zone and signe of latitude (N/S)
  32700 + utm_num - 100*( sign(lat) + 1 )/2 
}

#' EPSG codes for some common geographical coordinate systems 
#'
#' These are some of the datum names I have encountered in NWIS. If `code`
#' is not 'NAD27' or 'NAD83', the function assumes the WGS84 datum.
#'
#' @param code character, the datum name
#'
#' @return integer, the EPSG code
#' @export
#'
#' @examples
#' datum_to_epsg('WGS84')
#' datum_to_epsg('NAD27')
#' datum_to_epsg('some_unknown_datum')
datum_to_epsg = \(code) {
  
  code |> switch('NAD27' = 4267,
                 'NAD83' = 4269,
                 'WGS84' = 4326, 4326)
}


#' Return a vector of all downstream COMID values
#'
#' This uses the 'FROMCOMID' and 'TOCOMID' fields in the `edge` table to follow
#' the directed graph of flow lines downstream from the polygon represented by
#' the input(s) `comid`, all the way to the eventual outlet(s). The function returns
#' all COMIDs on the path(s) in a vector.
#' 
#' `comid` should be listed in `edge[['FROMCOMID']]`, otherwise the function
#' simply returns its first argument. `edge` is normally generated by `get_catch`
#' (which calls `get_upstream` to fetch it via `nhdR`) but it can be any data
#' frame with the same type of graph structure in the fields 'FROMCOMID' and
#' 'TOCOMID' (see examples).
#'
#' @param comid character vector, the COMID(s) uniquely identifying the catchment(s) of interest
#' @param edge data frame, the NHD "PlusFlow" table (see `?get_upstream`) 
#'
#' @return character vector, the COMID values encountered on the way to the outlet (in order)
#' @export
#'
#' @examples
#' # dummy table - these are not real COMIDs!
#' edge_eg = data.frame(
#'  FROMCOMID=c('00', '00', '10', '11', '20'),
#'  TOCOMID=c('10', '11', '20', '20', '30'))
#' 
#' # follow from upstream of fork
#' comid_down('00', edge_eg)
#' 
#' # follow from one side of fork then the other
#' comid_down('10', edge_eg)
#' comid_down('11', edge_eg)
#' 
comid_down = function(comid, edge, first_only=FALSE) { 
  
  # returns immediate downstream COMID(s) or empty character (if none)
  if(first_only) return( edge[['TOCOMID']][ edge[['FROMCOMID']] %in% comid ] )
  
  # if no downstream links return current node(s) only
  comid_found = comid_down(comid, edge, first_only=TRUE)
  if( length(comid_found) == 0 ) return(comid)
  
  # else call the function recursively on downstream node(s)
  return( unique( c(comid, comid_down(comid_found, edge)) ) )
}

#' Return a vector of all upstream COMID values
#'
#' This uses the 'FROMCOMID' and 'TOCOMID' fields in the `edge` table to follow
#' the directed graph of flow lines upstream from the polygon(s) represented by
#' the input `comid`. The function exhaustively checks all relevant branches in
#' a loop, returning all upstream COMID values in a vector
#' 
#' All entries of `comid` should be listed in `edge[['FROMCOMID']]`. Normal usage
#' is to pass a single value to `comid` identifying your outlet of interest. The
#' function uses vectorized calls internally.
#' 
#' `edge` is normally generated by `get_catch` (which calls `get_upstream` to fetch
#' it via `nhdR`) but it can be any data frame with the same type of graph structure
#' in the fields 'FROMCOMID' and 'TOCOMID' (see examples).
#'
#' @param comid character vector, the COMID values to start from
#' @param edge data frame, the NHD "PlusFlow" table (see `?get_upstream`) 
#'
#' @return character vector, the COMID values for polygons draining into the outlet
#' @export
#'
#' @examples
#' # dummy table - these are not real COMIDs!
#' edge_eg = data.frame(
#'  FROMCOMID=c('00', '00', '10', '11', '20'),
#'  TOCOMID=c('10', '11', '20', '20', '30'))
#' 
#' # follow from downstream of fork to get all nodes
#' comid_up('30', edge_eg)
#' 
#' # follow from one side of fork then the other
#' comid_up('10', edge_eg)
#' comid_up('11', edge_eg)
comid_up = function(comid, edge, first_only=FALSE) { 
  
  # returns immediate upstream COMID(s) or empty character (if none)
  if(first_only) {
    
    comid_found = edge[['FROMCOMID']][ edge[['TOCOMID']] %in% comid ]
    
    # code '0' represents headwaters polygon (ie a dead end)
    comid_found = comid_found[ comid_found != '0' ]
    return(comid_found) 
  }
  
  # if no upstream links return current node(s) only
  comid_found = comid_up(comid, edge, first_only=TRUE)
  if( length(comid_found) == 0 ) return(comid)
  
  # else call the function on upstream nodes
  return( c(comid, comid_up(comid_found, edge)) )
}


#' Omit all but the largest in a set of polygons
#' 
#' This selects the largest polygon from a set, transforms to WGS84 coordinates,
#' runs `sf::st_make_valid()`, then removes holes from the result.
#' 
#' This is useful for tidying up the result of set operations (like differencing)
#' when the expected result is a single connected polygon.
#'
#' @param poly_list any object for which `sf::st_geometry() |> sf::st_area()` is valid
#'
#' @return an sfc_polygon object
#' @export
biggest_poly = function(poly_list) {
  
  poly_list = poly_list |> sf::st_geometry() |> sf::st_make_valid()
  do.call(c, lapply(seq_along(poly_list), \(i) {

    # selects max area polygon from the set than transforms back to WGS84
    p = poly_list[i] |> sf::st_cast('POLYGON') |> sf::st_make_valid()
    p = p[ which.max( sf::st_area(p) ) ] |> sf::st_transform(4326) |> sf::st_make_valid() 
    
    # remove holes from result (using the trick in `mapsf::mf_scale`)
    p = sf::st_multipolygon(lapply(p, function(x) x[1])) |> sf::st_geometry()
    sf::st_crs(p) = 4326
    return(p)
    
  }))
}


#' Create a scale bar and add it to an sf plot
#' 
#' This returns a LINESTRING geometry representing a scale bar, and optionally draws
#' it on the plot along with a label giving the distance and units.
#' 
#' The function returns a LINESTRING geometry of known length located in one of the four
#' corners of the bounding box for `obj` (depending on the choice of `bottom` and `left`).
#' The length is selected by finding a `pretty` number close (but less than or equal) to
#' `size` times the horizontal span of the bounding box, and the units are always in 'km'
#' (or 'm' if the distance is less than 1 km).
#' 
#' Move the text label up and down with respect to the scale bar line using `y_adj`,
#' expressed in units of character height. Move the whole scale bar inwards or outwards
#' using `outer_adj`, expressed as a proportion of the square root of the area of the
#' bounding box. `cex`, `col`, `lwd` have their usual meanings (see `?plot`) and `col`
#' is applied to box the line and text. `box_col` causes the function to first draw a
#' rectangle of the requested color behind the scale bar (`box_border` is also passed to
#' `rect` to set the border color).
#' 
#' Calculations are done in the UTM projection but the results are returned in the
#' coordinate system of the input `obj`. This means scale bars for plots in other
#' coordinate systems (especially lon/lat) may look curved, but the reported path length
#' of the line segment drawn will be accurate.
#'
#' @param obj the sf object that was used to create the plot
#' @param bottom logical, whether to position the scale bar at top or bottom
#' @param left logical, whether to position the scale bar at left or right
#' @param draw logical, whether to draw the scale bar or just return it
#' @param above logical, whether to position the text above or below the line
#' @param size numeric > 0 controls the width of the scale bar (see details)
#' @param y_adj numeric, up/down position adjustment factor for text 
#' @param outer_adj, outer/inner position adjustment factor for scale bar
#' @param col passed to both `sf::plot.sf` and `text` for drawing
#' @param box_col character or NA, a color for painting the box behind the scale bar
#' @param lwd numeric line width, passed to `sf::plot.sf`
#' @param cex numeric text size expansion factor, passed to `text`
#'
#' @return sf LINESTRING data frame describing and positioning the scale bar 
#' @export
draw_scale = function(obj, bottom=TRUE, left=FALSE, draw=TRUE, above=bottom,
                      size=1/5, y_adj=0, outer_adj=0, lwd=2, cex=1,
                      col='grey30', box_col=NA, box_border=NA) {
  
  # take bounding box polygon and project to UTM coordinates
  crs_in = sf::st_crs(obj)
  crs_utm = to_utm(obj) |> suppressMessages()
  bbox_utm = sf::st_geometry(obj) |> sf::st_bbox() |> sf::st_as_sfc() |> sf::st_transform(crs_utm)
  
  # add buffer then take bounding box of result
  pad_dist = outer_adj * sqrt( sf::st_area(bbox_utm) )
  bbox_pad = sf::st_buffer(bbox_utm, pad_dist) |> sf::st_bbox() |> sf::st_as_sfc()

  # extract line geometry from bounding box
  bbox_line = bbox_pad |> sf::st_cast('LINESTRING') 
  
  # copy the horizontal line segment of the padded bounding box - scale-bar gets drawn here
  idx_draw = if(bottom) 1:2 else 4:3
  if(!left) idx_draw = rev(idx_draw)
  origin_line = bbox_line[[1]][idx_draw,] |> sf::st_linestring() |> sf::st_sfc(crs=crs_utm)
  
  # measure whole side length then scale down to a lower and prettier number (based on `size`)
  origin_len = origin_line |> sf::st_cast('POINT') |> sf::st_distance() |> max()
  output_len = pretty( size * ( origin_len - (2 * pad_dist) ) )[1]
  
  # construct shortened line segment using scaling factor determined above
  size_as_p =  output_len / units::drop_units(origin_len)
  output_xy = origin_line |> sf::st_cast('POINT') |> sf::st_coordinates()
  output_xy[2,'X'] = output_xy[1,'X'] + ifelse(left, 1, -1) * size_as_p * diff(sort(output_xy[,'X'])) 
  output_line = sf::st_linestring(output_xy) |> sf::st_sfc(crs=crs_utm) |> sf::st_transform(crs_in)
  
  # text label and units
  output_m = output_len |> units::set_units('m') |> units::drop_units()
  print_len = ifelse(output_m > 1e3, output_m/1e3, output_m)
  print_unit = ifelse(output_m > 1e3, 'km', 'm')
  print_msg = paste(print_len, print_unit)
  
  # positioning for the label
  y_pad =  ifelse(above, 1, -1) * strheight('0')
  xy_msg = sf::st_coordinates( sf::st_centroid(output_line) ) + c(0, y_adj * y_pad)
  
  # create an sf data frame from this information
  output_sf = data.frame(distance=print_msg, label=print_msg, x=xy_msg[1], y=xy_msg[2]) |> 
    sf::st_sf(geometry=output_line)
  
  # attempt to draw the line and label
  if(draw) {
    
    # draw a rectangle behind it first 
    if( !anyNA(box_col) ) {
      
      xy_line = output_line |> sf::st_cast('POINT') |> sf::st_coordinates()
      rect(xleft = min(xy_line[,'X']) - abs(y_pad),
           xright = max(xy_line[,'X']) + abs(y_pad),
           ybottom = min(xy_line[,'Y']) - abs(y_pad) + ifelse(above, 0, (1.5 + y_adj) * y_pad),
           ytop = max(xy_line[,'Y']) + abs(y_pad) + ifelse(above, (1.5 + y_adj) * y_pad, 0),
           col = box_col,
           border = box_border)
    }
    
    # now draw line with plot.sf and text
    plot(output_line, add=TRUE, xpd=TRUE, col=col, lwd=lwd)
    text(xy_msg[1], xy_msg[2], print_msg, pos=ifelse(above, 3, 1), xpd=TRUE, col=col, cex=cex)
  }
  
  return( invisible(output_sf) )
}


